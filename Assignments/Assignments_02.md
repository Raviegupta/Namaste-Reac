# Episode 01 - Inception (Date:- 30/Dec/23)

### What is NPM ?
- It is the default package manager for Node.js. (a popular runtime environment for running JavaScript on the server-side.)
- npm is used to install, share, and manage dependencies (both local and global) for Node.js projects.
- It allows developers to specify project dependencies in a package.json file and easily install or update them using simple commands.
- Scripts: npm allows developers to define custom scripts in their package.json file, which can be executed using the `npm run` command.

#### Why do we use npm in our app ?
- **basically, it is used to manage our packages**.
- **bcoz we want lot of packages in our app**.
- *bcoz our react app can't be build by just injecting react into our web pages*.
- **react app is a huge app, it doesnot run on only react, it requires lot of superpowers too, which we need & those superpowers comes from different packages. and those packages are present by using npm**.

### What is npx ?
- `npx` is `a command-line tool` that comes with npm
- It is used to execute Node.js packages directly, either from a local node_modules folder or from the npm registry. <br>

use cases of npx: 
- npx provides a convenient way `to execute Node.js packages and commands` without the need for manual installation or management, making it a useful tool for development workflows.
- **Executing Packages:** :- `npx` allows us to run a package without having to install it globally or locally.
- **Package Discovery** : npx can also be used to discover and run packages from the npm registry without having to know the exact package name or version. For example, we can run `npx create-react-app my-app` to create a new React app without having to install create-react-app globally.

### What is difference between `dependencies` vs `devDependencies`?
**dependencies** : Packages required by our application in `production`.
**devDependencies** : Packages that are only needed for `local development and testing`.

###  What is `.gitignore`? What should we add and not add into it?
- gitignore is a file used by the version control system Git to specify intentionally untracked files that Git should ignore.
- These untracked files are often files generated as part of the local development process or files that contain sensitive information, temporary files, or build artifacts that should not be committed to the repository.
- whatever we can regenerate, we don't push to git.
- and whatever we don't push them to git, we have to add them in gitignore.
- Common Use Cases:
    1. Ignoring auto-generated files (e.g., log files, cache files, build artifacts).
    2. Ignoring sensitive information (e.g., API keys, credentials) that should not be committed to the repository.
```
# Ignore all files with .log extension
*.log

# Ignore node_modules directory
node_modules/

# Ignore .env files containing environment-specific settings
.env
```

### - What is the difference between `package.json` and `package-lock.json`
`package.json`
- configuration file for npm
- defines metaDeta of our project
- it tells us what version of package is installed
- we can do manuall edit here

`package-lock.json`
- automatically generated by npm/yarn when dependencies are installed or updated.
- manuall edit or modification is not recoomended.
- it tell what `exact version` of library we are using. (package-lock.json me caret ya tilde use ni hota )
- it locks the specific version.
- it maintain the what exact version we are using on our systenm, will be exactly same on the server or production. => that is what integrity is there in package-lock-json (sha512)

#### Why should I not modify `package-lock.json`?
Modifying the package-lock.json file directly is generally not recommended for several reasons:
-  It is designed to be a representation of the exact dependency tree that was generated when you installed your project's dependencies. Manually editing this file can lead to inconsistencies between your dependencies and what is specified in the package-lock.json.
- package-lock.json file ensures that the entire dependency tree for your project is consistent and reproducible.
- `Automatic Updates`: When you run commands like npm install, npm uses the package-lock.json file to determine which versions of dependencies to install.

### What is `node_modules` ? Is it a good idea to push that on git?
- it just like a database of our npm. (node_module is huge.)
- contains all the data that we fetch from npm

- Never put our node_modules in github repository (So, we should add node_modules to .gitignore )=> bcoz our package-lock.json has sufficient information to regenerate or recreate our node_modules exactly the same.
- we can regenerate node_modules if we have package.json & package-lock.json by using the commands `npm install`

### what does caret(^) & tilde(~) do in package.json ?
- <img src="https://i.ibb.co/m9Cgsyk/caret-tilde.png" alt="caret-tilde" width="500px">
- <img src="https://i.ibb.co/bL7w8ws/caret-tilde-2.png" alt="caret-tilde-2" width="500px">

- caret (^) :- updates all patches, minor versions.
- tilde (~) :- updates all patches(bug fix only).

---

### What is `Parcel/Webpack` ? Why do we need it?
- It's a `Bundler`. It is a package. ( What is a package :- package is like a module of javascript file. )
Note:- when we have to use package in our code. then we have to use package manager like npm or yarn.

* Since Parcel is a bunder.
    * it is bundling everything.
    * It also does minification.
    * dist folder k ander `.js file` me hamara code bi minified form me parcel rakhta h.
      * dist\index.6aeb0cf4.js => code minified, actually it doesn't remove console.log (we have to configure our project to remove console.log)
---

### What is HMR (Hot Module Replacement) ?
- HMR is one of the most useful features offered by webpack or parcel (bundlers). It allows all kinds of modules to be updated at runtime without the need for a full refresh.
- How HMR does this => 
    - with the help of something known as `File Watcher Algorithm` and Parcel is doing this for us.
    - `File Watcher Algorithm` is written in C++ therefore HMR is very fast.

---

### What are `.parcel-cache` and `dist` folders ?
- `.parcel-cache` :- parcel needs `some space` to do it's activity & extra stuffs in the form of .parcel-cache
- `dit` folder :- keeps the file minified for us.

1. `.parcel-cache` folder: 
    - The .parcel-cache folder is used by Parcel `to store cached data` related to the `build process`. This cache is used to `speed up` subsequent builds by reusing previously processed data, such as compiled assets, dependencies, and intermediate build artifacts.
    - The contents of this folder are generated and `managed by Parcel automatically` during the build process. It's generally safe to leave this folder untouched, as Parcel handles its management internally.

2. `dist` folder:
    - The dist folder (short for "distribution") used to `store the output of the build process`. 
    - In a React app, this folder typically contains the compiled, optimized, and bundled files that are ready for deployment to a production environment.
    - contents of the dist folder are `generated by Parcel based on the configuration and entry points` specified in our project.
    - The dist folder is often used when preparing a React app for deployment to a web server or hosting service. It represents the "distribution" version of the application that is optimized for production use.

---

### List down your favourite 5 superpowers of Parcel and describe any 3 of them in your own words
Main Functionality / SuperPowers of Parcel
1. HMR (Hot Module Replacement)
1. File Watcher Algorithm (C++)
1. Local Server
1. Bundling
1. Minify our code (Minification) 
1. Clean Our Code
1. Development & Production Build
1. SuperFast `Build Algorithm`
1. Image Optimisation
1. Caching while development
1. Compresssion (rename bhi karta h => name ko chota karta h)
1. Differential Bundling (take care of our older version)
    * *compatible with older version of browser*
    * it add polyfills
1. Parcel gives us facility to build our own **HTTP on dev**.
1. Parcel manages Port Number.
1. Consistent Hashing Algorithm.
1. Zero Configuration.
1. Tree Shaking :- removing unwanted code
1. Code Spliiting
1. Diagnostic (Good Error Handling)
1. Facility to host on `https`
1. Transpilation
1. Lazy mode (--lazy flag ka use karke => npx parcel index.html `--lazy`)

---

### Q. How do I make our app **older browser compatible** ? What is `browserlists` ?
* there is a package known as **browserslist** which is *already given by Parcel* in node_modules.
  * It uses some dependencies that are also installed.
* Ref:- https://www.npmjs.com/package/browserslist
* when we add the following to package.json: (this browserslist will take an array of some strings)
```
 "browserslist": [
    "defaults and supports es6-module",
    "maintained node versions"
  ]
```
  * "last 2 versions"           => 74% (Decent)
  * "last 2 chrome versions"    => 16% (Bad)
  * "Cover 99.5% in US"
  * "last 2 firefox versions"
  * "last 2 firefox, chrome version"

Note:- "last 2 chrome versions" doesn't mean that it will not work in other versions. It simply means, it `will definetly work in last 2 chrome versions.`

---

### Script types in html (MDN Docs)
Attributes
- async
- defer
- crossorigin

type
- type='module'
- nomodule